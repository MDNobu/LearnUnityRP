// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InstanceCulling


int _instanceCount;
int _size;
// mesh local space的bounds
float4 _bounds[8];
float4 _planes[6];

float4x4 _vpMatrix;
Texture2D _hizBuffer;

RWStructuredBuffer<float4x4> _matrixBuffer; // 全部instance物体的变换矩阵
AppendStructuredBuffer<float4x4> _validMatrixBuffer;  //剔除后剩余的变换矩阵
RWStructuredBuffer<uint> _argsBuffer;

int GetSide(float4 inPlane, float3 inP)
{
    return (dot(inPlane.xyz, inP) + inPlane.w) > 0 ? 1 : 0;
}

int IsInside(float4 inPlanes[6], float3 inP)
{
    int count = 0;
    for (int i = 0; i < 6; ++i)
    {
        count += GetSide(inPlanes[i], inP);
    }
    return count == 6 ? 1 : 0;
}

bool Visibility(float4 inPlanes[6], float4 inBounds[8])
{
    int count = 0;
    for (int i = 0; i < 8; ++i)
    {
        count += IsInside(inPlanes, inBounds[i]);
    }
    return count > 0;
}

[numthreads(128,1,1)]
void InstanceCulling (
    uint3 gid : SV_GroupID,
    uint3 gtid : SV_GroupThreadID
)
{
    uint instanceIndex = gid.x * 128 + gtid.x;
    if (instanceIndex >= (uint)_instanceCount)
    {
        return;
    }

    float4x4 objectToWorld = _matrixBuffer[instanceIndex];

    // bounding box to world space
    float4 boundsWS[8];
    for (int i = 0; i < 8; ++i)
    {
        boundsWS[i] = mul(objectToWorld, _bounds[i]);
    }

    bool vis = Visibility(_planes, boundsWS);
    if (!vis)
    {
        return;
    }

    _validMatrixBuffer.Append(objectToWorld);
    InterlockedAdd(_argsBuffer[1], 1);
}
